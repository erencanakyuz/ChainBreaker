<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Chain Breaker Pro - Precision Ring-Breaking Game</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¯</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    #game-container {
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #333;
      border-radius: 8px;
    }

    .menu-button {
      font-size: 24px;
      cursor: pointer;
    }

    /* Loading screen iÃ§in */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      z-index: 1000;
    }
  </style>
</head>

<body>
  <div id="loading">
    <div>Chain Breaker Pro YÃ¼kleniyor...</div>
  </div>

  <div id="game-container">
    <div id="phaser-game"></div>
  </div>

  <!-- Load Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <script>
    // BootScene: YÃ¼kleme iÅŸlemlerini yapar.
    class BootScene extends Phaser.Scene {
      constructor() {
        super('BootScene');
      }

      preload() {
        const { width, height } = this.cameras.main;
        let progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(width / 2 - 160, height / 2 - 25, 320, 50);

        let loadingText = this.add.text(width / 2, height / 2 - 50, 'Loading...', { font: '20px Arial', fill: '#ffffff' }).setOrigin(0.5);

        this.load.on('progress', (value) => {
          let bar = this.add.graphics();
          bar.fillStyle(0xffffff, 1);
          bar.fillRect(width / 2 - 150, height / 2 - 15, 300 * value, 30);
        });

        this.load.on('complete', () => {
          progressBox.destroy();
          loadingText.destroy();
        });

        // Break efektleri iÃ§in particle texture
        let particleGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        particleGraphics.fillStyle(0xffffff, 1);
        particleGraphics.fillCircle(4, 4, 4);
        particleGraphics.generateTexture('particle', 8, 8);

        // Arka plan iÃ§in star texture
        let starGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        starGraphics.fillStyle(0xffffff, 1);
        starGraphics.fillRect(0, 0, 2, 2);
        starGraphics.generateTexture('star', 2, 2);
      }

      create() {
        this.scene.start('MenuScene');
      }
    }

    // MenuScene: Oyuncunun mod seÃ§ebileceÄŸi ana menÃ¼.
    class MenuScene extends Phaser.Scene {
      constructor() {
        super('MenuScene');
      }

      create() {
        const { width, height } = this.cameras.main;
        // BaÅŸlÄ±k ve arka plan
        this.add.text(width / 2, 80, 'Precision Ring-Breaking Game', {
          font: '40px Arial',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 5
        }).setOrigin(0.5);

        this.add.text(width / 2, 150, 'Select Mode', { font: '32px Arial', fill: '#ffff00', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5);

        // MenÃ¼ seÃ§enekleri (modeDesigns)
        this.modeDesigns = [
          {
            name: "Beginner's Circle",
            theme: "Standard rings with stationary targets",
            color: 0x00aaff,
            bgColor: 0x001a33,
            particleColors: [0x00aaff, 0x00cfff, 0x0099ff],
            ringColors: [0x00aaff, 0xff0000, 0x00ff00, 0xffff00],
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1,
            ringMovement: false
          },
          {
            name: "Speedy Spins",
            theme: "Faster needle movement",
            color: 0x0099ff,
            bgColor: 0x001133,
            particleColors: [0x0099ff, 0x00bfff, 0x0077ff],
            ringColors: [0x0099ff, 0xff00ff, 0x00ffff, 0xffaa00],
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1.3,
            ringMovement: false
          },
          {
            name: "Moving Targets",
            theme: "Sweet spots begin to rotate",
            color: 0x0088ff,
            bgColor: 0x001122,
            particleColors: [0x0088ff, 0x00aaff, 0x0066ff],
            ringColors: [0x0088ff, 0xff8800, 0xff0088, 0x88ff00],
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1.2,
            ringMovement: true,
            ringSpeed: 0.0005
          },
          {
            name: "Narrowing Path",
            theme: "Smaller sweet spots to hit",
            color: 0x0077ff,
            bgColor: 0x000f33,
            particleColors: [0x0077ff, 0x0099ff, 0x0055ff],
            ringColors: [0x0077ff, 0x77ff77, 0xff7777, 0xffbb00],
            specialEffects: true,
            sweetSpotSize: 10,
            needleSpeed: 1.3,
            ringMovement: true,
            ringSpeed: 0.0007
          },
          {
            name: "Chaos Theory",
            theme: "Unpredictable needle movements",
            color: 0x0066ff,
            bgColor: 0x000a22,
            particleColors: [0x0066ff, 0x0088ff, 0x0044ff],
            ringColors: [0x0066ff, 0xff6600, 0x66ff66, 0xff0066],
            specialEffects: true,
            sweetSpotSize: 12,
            needleSpeed: 1.4,
            ringMovement: true,
            ringSpeed: 0.001,
            needleReverseProb: 0.005
          },
          {
            name: "Master of Precision",
            theme: "The ultimate challenge",
            color: 0x0055ff,
            bgColor: 0x000822,
            particleColors: [0x0055ff, 0x0077ff, 0x0033ff],
            ringColors: [0x0055ff, 0xff5500, 0x55ff55, 0xff55ff],
            specialEffects: true,
            sweetSpotSize: 8,
            needleSpeed: 1.8,
            ringMovement: true,
            ringSpeed: 0.0015,
            needleReverseProb: 0.005,
            pulsingRings: true
          }
        ];

        let startY = 220, spacing = 60;
        this.modeDesigns.forEach((mode, index) => {
          let modeText = this.add.text(width / 2, startY + index * spacing, mode.name, { font: '28px Arial', fill: '#ffffff', stroke: '#000000', strokeThickness: 3 })
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });

          modeText.on('pointerdown', () => {
            this.scene.start('MainScene', { selectedMode: mode });
          });

          modeText.on('pointerover', () => { modeText.setFill('#ffff00'); });
          modeText.on('pointerout', () => { modeText.setFill('#ffffff'); });
        });
      }
    }

    // MainScene: Oyun mekaniÄŸini barÄ±ndÄ±rÄ±r.
    class MainScene extends Phaser.Scene {
      constructor() {
        super('MainScene');
        // Object pools for memory efficiency
        this.scorePopupPool = [];
        this.ringPool = [];
        this.maxPoolSize = 20;
      }

      init(data) {
        this.selectedMode = data.selectedMode || null;
        this.level = 1;
        this.lastUpdateTime = 0;
        this.targetFPS = 60;
        this.frameBudget = 1000 / this.targetFPS;
      }

      create() {
        // --- Arka plan ve ek particle efektleri ---
        this.backgroundParticles = this.add.particles('star');
        this.backgroundEmitter = this.backgroundParticles.createEmitter({
          x: { min: 0, max: this.cameras.main.width },
          y: 0,
          lifespan: 8000,
          speedY: { min: 10, max: 30 },
          scale: { start: 1, end: 0 },
          quantity: 6,
          blendMode: 'ADD'
        });

        // Optimized background particles - reduced quantity and increased lifespan
        this.bgParticles = this.add.particles('particle');
        this.bgEmitter = this.bgParticles.createEmitter({
          x: { min: 0, max: this.cameras.main.width },
          y: { min: 0, max: this.cameras.main.height },
          lifespan: 15000,  // Longer lifespan, fewer spawns
          speed: { min: 10, max: 50 },
          angle: { min: 0, max: 360 },
          scale: { start: 0.3, end: 0 },
          quantity: 1, // Reduced from 3 to 1
          frequency: 500, // Add frequency control
          blendMode: 'ADD',
          tint: [0x0088ff, 0x00ffcc, 0x0055ff],
          alpha: { start: 0.5, end: 0 } // Reduced alpha for better performance
        });

        // Optimized spark emitter with pooling
        this.sparkEmitter = this.add.particles('particle').createEmitter({
          x: 0,
          y: 0,
          lifespan: 300, // Reduced lifespan
          speed: { min: -150, max: 150 }, // Reduced speed range
          scale: { start: 1.2, end: 0 }, // Slightly smaller
          quantity: 15, // Reduced from 30 to 15
          blendMode: 'ADD',
          tint: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00],
          on: false
        });

        // Optimized break particles
        this.breakParticles = this.add.particles('particle');
        this.breakEmitter = this.breakParticles.createEmitter({
          lifespan: 600, // Reduced lifespan
          speed: { min: 60, max: 150 }, // Reduced speed
          scale: { start: 0.8, end: 0 }, // Smaller particles
          quantity: 20, // Reduced from 40 to 20
          blendMode: 'ADD',
          gravityY: 80, // Reduced gravity
          on: false
        });

        // Fever Mode partikÃ¼lleri
        this.feverParticles = this.add.particles('particle');
        this.feverEmitter = this.feverParticles.createEmitter({
          x: { min: 0, max: this.cameras.main.width },
          y: { min: 0, max: this.cameras.main.height },
          lifespan: 5000,
          speed: { min: 50, max: 100 },
          scale: { start: 0.4, end: 0 },
          quantity: 5,
          blendMode: 'ADD',
          tint: [0xff0000, 0xff8800, 0xffff00], // KÄ±rmÄ±zÄ± & SarÄ± tonlarÄ±
          alpha: { start: 1, end: 0 }
        });
        this.feverEmitter.stop(); // Fever Mode baÅŸta kapalÄ± olacak

        this.confettiParticles = this.add.particles('particle');
        this.confettiEmitter = this.confettiParticles.createEmitter({
          x: { min: 0, max: this.cameras.main.width },
          y: 0,
          speed: { min: 100, max: 200 },
          angle: { min: 80, max: 100 },
          scale: { start: 1, end: 0 },
          lifespan: 3000,
          tint: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff],
          on: false
        });

        this.center = { x: this.cameras.main.width / 2, y: this.cameras.main.height / 2 };
        this.flash = this.add.rectangle(0, 0, this.cameras.main.width, this.cameras.main.height, 0xccccff).setOrigin(0, 0);
        this.flash.alpha = 0;
        this.backgroundGlow = this.add.graphics();
        this.setupUI();
        this.setupParticleEffects();
        this.setupNeedle();
        this.input.on('pointerdown', this.handleInput, this);
        this.debugText = this.add.text(10, 130, '', { font: '16px Arial', fill: '#ffffff' });
        this.gameOverFlag = false;
        this.gameOverText = this.add.text(this.center.x, this.center.y, '', {
          font: '48px Arial', fill: '#ff0000', align: 'center',
          stroke: '#000000', strokeThickness: 6
        }).setOrigin(0.5);

        // Ã‡ember ayarlarÄ±
        this.baseRadius = 100;
        this.ringThickness = 20;
        this.ringGap = 15;
        this.setupLevelDesigns();
        this.startLevel();
      }

      setupUI() {
        this.score = 0;
        this.combo = 0;
        this.lives = 3;
        this.regenDelay = 5000;
        const textStyle = { font: '24px Arial', fill: '#ffffff', stroke: '#000000', strokeThickness: 3 };
        this.levelText = this.add.text(this.cameras.main.width / 2, 10, 'Level: ' + this.level, textStyle).setOrigin(0.5, 0);
        this.scoreText = this.add.text(10, 10, 'Score: 0', textStyle);
        this.comboText = this.add.text(10, 40, 'Combo: 0', { ...textStyle, fill: '#ffff00' });
        this.livesText = this.add.text(10, 70, 'Lives: 3', { ...textStyle, fill: '#ff5555' });
        this.feverMode = false;
        this.feverModeDuration = 5000;
        this.feverTimer = 0;
        this.feverText = this.add.text(10, 100, '', { ...textStyle, fill: '#ff00ff' });
        this.themeText = this.add.text(this.cameras.main.width / 2, 50, '', {
          font: '20px Arial', fill: '#00ffff', stroke: '#000000', strokeThickness: 3
        }).setOrigin(0.5, 0);
      }

      setupParticleEffects() {
        // Bu bÃ¶lÃ¼mde daha Ã¶nce oluÅŸturduÄŸumuz partikÃ¼l emitter'leri zaten create() iÃ§erisinde ayarlandÄ±.
      }

      setupNeedle() {
        this.needle = this.add.graphics();
        this.needleAngle = 0;
        this.originalNeedleSpeed = Phaser.Math.DegToRad(180);
        this.needleSpeed = this.originalNeedleSpeed;
        this.needleReverseProb = 0;
      }

      setupLevelDesigns() {
        if (this.selectedMode) {
          this.baseMode = this.selectedMode;
        } else {
          this.levelDesigns = [{
            name: "Beginner's Circle",
            theme: "Standard rings with stationary targets",
            color: 0x00aaff,
            bgColor: 0x001a33,
            particleColors: [0x00aaff, 0x00cfff, 0x0099ff],
            ringColors: [0x00aaff, 0xff0000, 0x00ff00, 0xffff00],
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1,
            ringMovement: false
          }];
        }
      }

      getActiveDesign() {
        // Cache the active design to avoid recalculation
        if (this.cachedDesign && this.cachedDesign.level === this.level) {
          return this.cachedDesign;
        }

        let design;
        if (this.baseMode) {
          const mod = this.level - 1;
          const difficultyMultiplier = Math.min(mod * 0.08, 3); // Cap difficulty scaling

          design = {
            name: this.baseMode.name,
            theme: this.baseMode.theme,
            color: this.baseMode.color,
            bgColor: this.baseMode.bgColor,
            particleColors: this.baseMode.particleColors,
            ringColors: this.baseMode.ringColors,
            specialEffects: this.baseMode.specialEffects,
            sweetSpotSize: Math.max(this.baseMode.sweetSpotSize - mod * 0.5, 3), // Slower reduction
            needleSpeed: this.baseMode.needleSpeed * (1 + difficultyMultiplier),
            ringMovement: this.baseMode.ringMovement,
            ringSpeed: (this.baseMode.ringSpeed || 0) * (1 + difficultyMultiplier * 0.5),
            needleReverseProb: this.baseMode.needleReverseProb || 0
          };
        } else {
          const designIndex = Math.min(this.level - 1, this.levelDesigns.length - 1);
          design = this.levelDesigns[designIndex];
        }

        // Cache the design with level info
        this.cachedDesign = { ...design, level: this.level };
        return design;
      }

      update(time, delta) {
        if (this.gameOverFlag) return;

        // Frame budgeting for consistent performance
        const startTime = performance.now();
        let dt = delta / 1000;
        this.frameCount = (this.frameCount || 0) + 1;

        // Priority 1: Critical game logic (always runs)
        this.updateNeedle(dt);
        this.updateFeverMode(delta);

        // Priority 2: Visual updates (skip if frame budget exceeded)
        if (performance.now() - startTime < this.frameBudget * 0.7) {
          // Update background glow less frequently (every 3rd frame)
          if (this.frameCount % 3 === 0) {
            this.updateBackgroundGlow(time);
          }

          // Batch ring updates - limit to 2 rings per frame for performance
          const ringsToUpdate = Math.min(2, this.ringStack.length);
          for (let i = 0; i < ringsToUpdate; i++) {
            const ring = this.ringStack[i];
            if (ring.needsUpdate) {
              ring.update(delta);
            }
          }
        }

        // Priority 3: Non-critical updates (skip if running slow)
        if (performance.now() - startTime < this.frameBudget * 0.9) {
          if (this.frameCount % 15 === 0) { // Reduced frequency further
            this.debugText.setText(
              'FPS: ' + Math.round(1000 / delta) +
              '\nCombo: ' + this.combo +
              '\nLevel: ' + this.level
            );
          }
        }
      }

      updateBackgroundGlow(time) {
        const intensity = this.feverMode ? 0.3 : 0.1;
        const pulseFactor = Math.sin(time / 500) * 0.05 + intensity;
        this.backgroundGlow.clear();
        this.backgroundGlow.fillStyle(this.getActiveDesign().color, pulseFactor);
        this.backgroundGlow.fillCircle(this.center.x, this.center.y, this.baseRadius * 3);
      }

      updateNeedle(dt) {
        const design = this.getActiveDesign();
        if (design.needleReverseProb && Math.random() < design.needleReverseProb) {
          this.needleSpeed = -this.needleSpeed;
        }

        const oldAngle = this.needleAngle;
        this.needleAngle += this.needleSpeed * dt;
        if (this.needleAngle >= Math.PI * 2) this.needleAngle -= Math.PI * 2;
        if (this.needleAngle < 0) this.needleAngle += Math.PI * 2;

        // Only redraw if angle changed significantly (optimization)
        if (Math.abs(oldAngle - this.needleAngle) > 0.01) {
          this.drawNeedle();
        }
      }

      updateFeverMode(delta) {
        if (this.feverMode) {
          this.feverTimer -= delta;
          if (this.feverTimer <= 0) {
            this.feverMode = false;
            this.feverText.setText('');
          } else {
            this.feverText.setText('FEVER MODE: ' + Math.ceil(this.feverTimer / 1000) + 's');
          }
        }
      }

      drawNeedle() {
        if (!this.activeRing) return;

        this.needle.clear();
        const baseColor = this.feverMode ? 0xff00ff : 0xffffff;

        // Pre-calculate frequently used values
        const outerEdge = this.activeRing.radius + this.activeRing.thickness / 2;
        const margin = 46;
        const markerRadius = 15;

        // Cache trigonometric calculations
        const cosAngle = Math.cos(this.needleAngle);
        const sinAngle = Math.sin(this.needleAngle);

        // Pre-calculate positions
        const startDistance = outerEdge + margin;
        const endDistance = outerEdge + 5;

        const startX = this.center.x + cosAngle * startDistance;
        const startY = this.center.y + sinAngle * startDistance;
        const endX = this.center.x + cosAngle * endDistance;
        const endY = this.center.y + sinAngle * endDistance;

        // Use batch drawing for better performance
        this.needle.lineStyle(20, baseColor, 0.4);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX, startY, endX, endY));

        this.needle.lineStyle(4, baseColor, 1);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX, startY, endX, endY));

        this.needle.fillStyle(baseColor, 1);
        this.needle.fillCircle(endX, endY, markerRadius);

        this.needle.lineStyle(3, 0x000000, 1);
        this.needle.strokeCircle(endX, endY, markerRadius);
      }

      handleInput() {
        if (this.gameOverFlag || !this.activeRing) return;

        // Prevent input spam - minimum 100ms between inputs
        const now = performance.now();
        if (this.lastInputTime && now - this.lastInputTime < 100) return;
        this.lastInputTime = now;

        this.activeRing.inputReceived = true;

        // Cached angle difference calculation
        const angleDiff = Phaser.Math.Angle.Wrap(this.needleAngle - this.activeRing.sweetSpotAngle);
        const absAngleDiff = Math.abs(angleDiff);

        // Pre-calculate threshold to avoid repeated calculations
        if (!this.cachedThreshold) {
          this.cachedThreshold = Phaser.Math.DegToRad(this.getActiveDesign().sweetSpotSize);
        }

        if (absAngleDiff <= this.cachedThreshold) {
          this.handleSuccessfulHit();
        } else {
          this.handleMiss();
        }
        this.resetRegenTimer();
      }

      handleSuccessfulHit() {
        this.flash.alpha = 1;
        this.tweens.add({
          targets: this.flash,
          alpha: 0,
          duration: 150,
          ease: 'Linear'
        });

        // KÄ±rÄ±lan halkanÄ±n rengini alÄ±p, break emitter'a uygula
        this.breakEmitter.setTint(this.activeRing.ringColor);
        this.breakEmitter.explode(30, this.center.x, this.center.y);

        // Ek spark efekti
        this.sparkEmitter.explode(30, this.center.x, this.center.y);
        this.cameras.main.shake(150, 0.01);

        // Arka plan partikÃ¼llerinin rengini, aktif tasarÄ±mÄ±n particleColors dizisine gÃ¶re ayarla
        this.bgEmitter.setTint(this.getActiveDesign().particleColors);

        // Fever Mode aktifse ek partikÃ¼l efekti Ã§alÄ±ÅŸtÄ±r
        if (this.feverMode) {
          this.feverEmitter.start();
          this.time.delayedCall(500, () => { this.feverEmitter.stop(); });
        }

        let multiplier = this.feverMode ? 2 : (1 + this.combo * 0.1);
        let points = Math.floor(10 * multiplier);
        let popupX = this.center.x + Math.cos(this.needleAngle) * this.activeRing.radius;
        let popupY = this.center.y + Math.sin(this.needleAngle) * this.activeRing.radius;
        this.showScorePopup(points, popupX, popupY);

        this.tweens.add({
          targets: this.activeRing.graphics,
          scaleX: 0,
          scaleY: 0,
          ease: 'Power2',
          duration: 200,
          onComplete: () => {
            this.activeRing.destroy();
            Phaser.Utils.Array.Remove(this.ringStack, this.activeRing);
            if (this.ringStack.length === 0) {
              this.levelUp();
            } else {
              this.activeRing = this.ringStack[this.ringStack.length - 1];
            }
          }
        });
        this.combo++;
        this.comboText.setText('Combo: ' + this.combo);
        this.score += points;
        this.scoreText.setText('Score: ' + this.score);
        this.needleSpeed *= 1.03;
        this.regenDelay = Math.max(3000, this.regenDelay * 0.98);
        if (this.combo >= 5 && !this.feverMode) {
          this.activateFeverMode();
        }
      }

      // Optimized score popup with object pooling
      showScorePopup(points, x, y) {
        let popup = this.getPooledScorePopup();
        let baseScale = points >= 100 ? 2 : (points >= 50 ? 1.5 : 1);

        popup.setText('+' + points);
        popup.setPosition(x, y);
        popup.setScale(0);
        popup.setAlpha(1);
        popup.setVisible(true);

        this.tweens.timeline({
          targets: popup,
          tweens: [
            {
              scaleX: baseScale * 1.2,
              scaleY: baseScale * 0.8,
              angle: { from: -15, to: 0 },
              ease: 'Back.easeOut',
              duration: 400
            },
            {
              scaleX: baseScale,
              scaleY: baseScale,
              duration: 200
            },
            {
              y: popup.y - 80,
              alpha: 0,
              ease: 'Power2',
              duration: 800,
              delay: 100
            }
          ],
          onComplete: () => this.returnPooledScorePopup(popup)
        });
      }

      getPooledScorePopup() {
        if (this.scorePopupPool.length > 0) {
          return this.scorePopupPool.pop();
        }
        return this.add.text(0, 0, '', {
          font: '48px Arial',
          fill: '#ffdd00',
          stroke: '#000000',
          strokeThickness: 4
        }).setOrigin(0.5).setShadow(4, 4, "#333333", 4, false, true);
      }

      returnPooledScorePopup(popup) {
        popup.setVisible(false);
        if (this.scorePopupPool.length < this.maxPoolSize) {
          this.scorePopupPool.push(popup);
        } else {
          popup.destroy();
        }
      }

      handleMiss() {
        this.combo = 0;
        this.comboText.setText('Combo: ' + this.combo);
        this.lives--;
        this.livesText.setText('Lives: ' + this.lives);
        this.cameras.main.shake(150, 0.015);
        this.tweens.add({
          targets: this.activeRing.graphics,
          x: this.activeRing.x + 5,
          y: this.activeRing.y + 5,
          yoyo: true,
          duration: 50,
          repeat: 2,
          onComplete: () => {
            this.activeRing.graphics.x = this.activeRing.x;
            this.activeRing.graphics.y = this.activeRing.y;
          }
        });
        if (this.lives <= 0) {
          this.gameOver();
        }
      }

      activateFeverMode() {
        this.feverMode = true;
        this.feverTimer = this.feverModeDuration;
        this.feverText.setText('FEVER MODE: 5s');
        this.cameras.main.flash(500, 255, 0, 255);
      }

      resetRegenTimer() {
        if (this.regenTimer) {
          this.regenTimer.remove(false);
        }
        this.regenTimer = this.time.addEvent({
          delay: this.regenDelay,
          callback: this.regenerateRing,
          callbackScope: this
        });
      }

      regenerateRing() {
        if (this.activeRing && !this.activeRing.inputReceived) {
          this.combo = 0;
          this.comboText.setText('Combo: 0');
        }
        if (this.ringStack.length >= 9) {
          this.gameOver();
          return;
        }
        let lastRadius = this.ringStack.length > 0
          ? this.ringStack[this.ringStack.length - 1].radius
          : this.baseRadius - (this.ringThickness + this.ringGap);
        let newRadius = lastRadius + this.ringThickness + this.ringGap;
        let ringColor = Phaser.Utils.Array.GetRandom(this.getActiveDesign().ringColors);
        let newRing = new Ring(this, this.center.x, this.center.y, newRadius, this.ringThickness, ringColor, this.getActiveDesign());
        this.ringStack.push(newRing);
        this.activeRing = newRing;
        this.resetRegenTimer();
      }

      levelUp() {
        this.confettiEmitter.explode(50, this.center.x, this.center.y);
        this.cameras.main.flash(500, 0, 255, 0);
        let levelUpText = this.add.text(this.center.x, this.center.y, 'LEVEL UP!', {
          font: '48px Arial',
          fill: '#00ff00',
          stroke: '#000000',
          strokeThickness: 5
        }).setOrigin(0.5);
        this.tweens.add({
          targets: levelUpText,
          alpha: 0,
          scale: 2,
          duration: 1000,
          ease: 'Power2',
          onComplete: () => levelUpText.destroy()
        });
        this.level++;
        this.levelText.setText('Level: ' + this.level);
        const design = this.getActiveDesign();
        this.themeText.setText(design.name + ': ' + design.theme);
        this.needleSpeed = this.originalNeedleSpeed * design.needleSpeed;
        this.needleReverseProb = design.needleReverseProb || 0;
        this.regenDelay = Math.max(2000, 5000 - (this.level * 200));
        if (this.level % 3 === 0) {
          this.lives = Math.min(this.lives + 1, 5);
          this.livesText.setText('Lives: ' + this.lives);
          let bonusText = this.add.text(this.center.x, this.center.y + 60, '+1 LIFE!', {
            font: '32px Arial',
            fill: '#ff5555',
            stroke: '#000000',
            strokeThickness: 4
          }).setOrigin(0.5);
          this.tweens.add({
            targets: bonusText,
            alpha: 0,
            y: this.center.y + 30,
            duration: 1200,
            ease: 'Power2',
            onComplete: () => bonusText.destroy()
          });
        }
        this.time.delayedCall(1000, () => { this.startLevel(); }, [], this);
      }

      startLevel() {
        const design = this.getActiveDesign();
        this.currentRingColor = design.color;
        this.cameras.main.setBackgroundColor(design.bgColor);
        this.bgEmitter.setTint(design.particleColors);
        this.themeText.setText(design.name + ': ' + design.theme);
        this.ringStack = [];

        // Dynamic ring count based on difficulty
        const numRings = Math.min(8, 6 + Math.floor(this.level / 5));
        const radiusIncrement = this.ringThickness + this.ringGap;

        // Pre-calculate colors for better performance
        const colorPool = [...design.ringColors];

        for (let i = 0; i < numRings; i++) {
          const radius = this.baseRadius + i * radiusIncrement;
          const ringColor = colorPool[i % colorPool.length]; // Cycle through colors
          const ring = new Ring(this, this.center.x, this.center.y, radius, this.ringThickness, ringColor, design);
          this.ringStack.push(ring);
        }

        this.activeRing = this.ringStack[this.ringStack.length - 1];

        // Invalidate cached values when starting new level
        this.cachedDesign = null;
        this.cachedThreshold = null;

        this.resetRegenTimer();
      }

      gameOver() {
        this.gameOverFlag = true;
        this.gameOverText.setText('GAME OVER\nScore: ' + this.score + '\nLevel: ' + this.level + '\nClick to Restart');
        this.ringStack.forEach(ring => {
          this.tweens.add({
            targets: ring.graphics,
            alpha: 0,
            duration: 500
          });
        });
        this.input.once('pointerdown', () => {
          this.resetGame();
          this.gameOverFlag = false;
          this.gameOverText.setText('');
        });
      }

      resetGame() {
        // Clear all timers and tweens
        if (this.regenTimer) this.regenTimer.remove(false);
        this.tweens.killAll();

        // Clean up ring stack
        if (this.ringStack) {
          this.ringStack.forEach(ring => ring.destroy());
          this.ringStack.length = 0; // Clear array
        }

        // Clean up object pools
        if (this.scorePopupPool) {
          this.scorePopupPool.forEach(popup => popup.destroy());
          this.scorePopupPool.length = 0;
        }

        // Memory cleanup (texture cache removed for stability)

        // Reset game state
        this.level = 1;
        this.score = 0;
        this.combo = 0;
        this.lives = 3;
        this.needleSpeed = this.originalNeedleSpeed;
        this.regenDelay = 5000;
        this.feverMode = false;
        this.cachedThreshold = null; // Clear cached threshold
        this.frameCount = 0;

        // Update UI
        this.levelText.setText('Level: ' + this.level);
        this.scoreText.setText('Score: 0');
        this.comboText.setText('Combo: 0');
        this.livesText.setText('Lives: 3');
        this.feverText.setText('');

        this.startLevel();
      }
    }

    // Ring sÄ±nÄ±fÄ±: Her Ã§emberi, glow, 3D gÃ¶lge, sweet spot ve ok ile Ã§izer.
    class Ring {
      constructor(scene, x, y, radius, thickness, ringColor, design = {}) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.thickness = thickness;
        this.ringColor = ringColor || 0x00ffff;
        this.graphics = scene.add.graphics({ x: x, y: y });
        this.sweetSpotAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
        this.debugText = null;
        this.design = design;
        this.pulseDirection = 1;
        this.pulseMagnitude = 0;
        this.inputReceived = false;
        this.movementEnabled = design.ringMovement || false;
        this.movementSpeed = design.ringSpeed || 0.0005;
        this.needsUpdate = this.movementEnabled || design.pulsingRings;

        // Performance: Pre-calculate frequently used values
        this.arcWidth = Phaser.Math.DegToRad(this.design.sweetSpotSize || 15);
        this.arrowCosCache = Math.cos(this.sweetSpotAngle);
        this.arrowSinCache = Math.sin(this.sweetSpotAngle);
        this.isDirty = true;
        this.hasDrawn = false;

        if (this.scene.debugMode) {
          this.debugText = this.scene.add.text(this.x, this.y, '', { font: '12px Arial', fill: '#ff0000' }).setOrigin(0.5);
        }
        this.draw();
      }

      draw() {
        // Only clear if necessary - check if ring actually changed
        if (!this.isDirty && this.hasDrawn) return;

        this.graphics.clear();

        // Simplified ring drawing without complex texture caching

        // Draw base ring directly (simplified approach to avoid texture caching issues)
        this.graphics.fillStyle(0x000000, 0.3);
        this.graphics.fillCircle(5, 5, this.radius);
        this.graphics.lineStyle(this.thickness + 4, this.ringColor, 0.3);
        this.graphics.strokeCircle(0, 0, this.radius);
        this.graphics.fillStyle(this.ringColor, 0.2);
        this.graphics.fillCircle(0, 0, this.radius);
        this.graphics.lineStyle(this.thickness, this.ringColor, 0.8);
        this.graphics.strokeCircle(0, 0, this.radius);

        // Draw dynamic elements (sweet spot and arrow)
        this.graphics.lineStyle(this.thickness, 0xffffff, 1);
        this.graphics.beginPath();
        this.graphics.arc(0, 0, this.radius, this.sweetSpotAngle - this.arcWidth, this.sweetSpotAngle + this.arcWidth, false);
        this.graphics.strokePath();

        // Pre-calculated arrow position
        const arrowX = this.arrowCosCache * (this.radius - this.thickness - 5);
        const arrowY = this.arrowSinCache * (this.radius - this.thickness - 5);

        this.graphics.fillStyle(0xffffff, 1);
        this.graphics.beginPath();
        this.graphics.moveTo(arrowX, arrowY);
        this.graphics.lineTo(arrowX - 5, arrowY - 10);
        this.graphics.lineTo(arrowX + 5, arrowY - 10);
        this.graphics.closePath();
        this.graphics.fillPath();

        this.hasDrawn = true;
        this.isDirty = false;

        if (this.debugText) {
          this.debugText.setText('Angle: ' + Math.round(Phaser.Math.RadToDeg(this.sweetSpotAngle)));
        }
      }

      update(delta) {
        let needsRedraw = false;

        if (this.movementEnabled) {
          const oldAngle = this.sweetSpotAngle;
          this.sweetSpotAngle += this.movementSpeed * delta;
          if (this.sweetSpotAngle > Math.PI * 2) this.sweetSpotAngle -= Math.PI * 2;

          // Only redraw if angle changed significantly
          if (Math.abs(oldAngle - this.sweetSpotAngle) > 0.005) {
            // Update cached trigonometric values
            this.arrowCosCache = Math.cos(this.sweetSpotAngle);
            this.arrowSinCache = Math.sin(this.sweetSpotAngle);
            this.isDirty = true;
            needsRedraw = true;
          }
        }

        if (this.design.pulsingRings) {
          const oldMagnitude = this.pulseMagnitude;
          this.pulseMagnitude += this.pulseDirection * 0.001 * delta;
          if (this.pulseMagnitude > 0.05 || this.pulseMagnitude < -0.05) this.pulseDirection *= -1;

          // Only update scale if magnitude changed significantly
          if (Math.abs(oldMagnitude - this.pulseMagnitude) > 0.001) {
            this.graphics.scaleX = 1 + this.pulseMagnitude;
            this.graphics.scaleY = 1 + this.pulseMagnitude;
          }
        }

        if (needsRedraw) {
          this.draw();
        }

        // Set needsUpdate flag for next frame
        this.needsUpdate = this.movementEnabled || this.design.pulsingRings;
      }

      destroy() {
        this.graphics.destroy();
        if (this.debugText) this.debugText.destroy();
      }
    }

    // Loading screen'i kaldÄ±r
    document.addEventListener('DOMContentLoaded', function () {
      const loadingElement = document.getElementById('loading');
      if (loadingElement) {
        loadingElement.style.display = 'none';
      }
    });

    const config = {
      type: Phaser.AUTO, // Let Phaser choose the best renderer
      width: 800,
      height: 600,
      parent: 'phaser-game',
      scene: [BootScene, MenuScene, MainScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 800,
        height: 600
      },
      backgroundColor: '#000000',
      // Simplified config to avoid canvas creation issues
      dom: {
        createContainer: true
      }
    };

    // Simple, reliable game initialization
    window.addEventListener('load', function () {
      // Wait a moment for everything to be ready
      setTimeout(() => {
        const loadingElement = document.getElementById('loading');
        if (loadingElement) {
          loadingElement.style.display = 'none';
        }

        // Create the game
        const game = new Phaser.Game(config);
      }, 500);
    });
  </script>
</body>

</html>