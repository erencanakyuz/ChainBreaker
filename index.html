<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Chain Breaker Pro - Precision Ring-Breaking Game</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¯</text></svg>">

  <!-- Enhanced CSS with gradient backgrounds and modern styling -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Arial', sans-serif;
      width: 100vw;
      height: 100vh;
    }

    #game-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
    }

    #phaser-game {
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      box-shadow: inset 0 0 100px rgba(0, 150, 255, 0.3);
    }

    .menu-button {
      font-size: 24px;
      cursor: pointer;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      border-radius: 12px;
      padding: 10px 20px;
      border: none;
      color: white;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .menu-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced loading screen with gradient */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      z-index: 1000;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    /* Animated loading indicator */
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-right: 20px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="loading">
    <div class="loading-spinner"></div>
    <div>Chain Breaker Pro YÃ¼kleniyor...</div>
  </div>

  <div id="game-container">
    <div id="phaser-game"></div>
  </div>

  <!-- Load external color libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>

  <!-- Load latest Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <script>
    // Advanced Color System using Chroma.js only
    class ColorSystem {
      constructor() {
        this.initializeColorPalettes();
      }

      initializeColorPalettes() {
        // Create sophisticated cartoon-style color palettes using Chroma.js
        this.palettes = {
          neon: chroma.scale(['#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57']).mode('lch').colors(8),
          sunset: chroma.scale(['#FF6B9D', '#F38BA8', '#E8B4CB', '#C8A2C8']).mode('lch').colors(8),
          ocean: chroma.scale(['#74B9FF', '#0984E3', '#6C5CE7', '#A29BFE']).mode('lab').colors(8),
          fire: chroma.scale(['#E17055', '#FDCB6E', '#F39C12', '#E67E22']).mode('lch').colors(8),
          cosmic: chroma.scale(['#6C5CE7', '#A29BFE', '#FD79A8', '#FDCB6E']).mode('lch').colors(8),
          aurora: chroma.scale(['#00CEC9', '#55EFC4', '#81ECEC', '#74B9FF']).mode('lch').colors(8)
        };

        // Convert to Phaser-compatible hex integers
        this.convertedPalettes = {};
        Object.keys(this.palettes).forEach(key => {
          this.convertedPalettes[key] = this.palettes[key].map(color =>
            parseInt(color.replace('#', '0x'), 16)
          );
        });
      }

      // Get dynamic color based on level and mode using Chroma.js
      getDynamicColor(level, baseColor, intensity = 1) {
        const color = chroma(baseColor);
        const hue = (color.get('hsl.h') + (level * 30)) % 360;
        const saturation = Math.min(1, color.get('hsl.s') * intensity);
        const lightness = Math.max(0.2, Math.min(0.8, color.get('hsl.l') * intensity));

        return parseInt(chroma.hsl(hue, saturation, lightness).hex().replace('#', '0x'), 16);
      }

      // Generate complementary colors using Chroma.js
      getComplementaryColors(baseColor, count = 4) {
        const baseChroma = chroma(baseColor);
        const colors = [];
        const hueStep = 360 / count;
        const baseHue = baseChroma.get('hsl.h');

        for (let i = 0; i < count; i++) {
          const newHue = (baseHue + (i * hueStep)) % 360;
          colors.push(parseInt(chroma.hsl(newHue, baseChroma.get('hsl.s'), baseChroma.get('hsl.l')).hex().replace('#', '0x'), 16));
        }
        return colors;
      }

      // Get animated color transition using Chroma.js
      getAnimatedColor(baseColor, time, speed = 1) {
        const color = chroma(baseColor);
        const hueShift = Math.sin(time * speed) * 30;
        const newHue = (color.get('hsl.h') + hueShift) % 360;

        return parseInt(chroma.hsl(newHue, color.get('hsl.s'), color.get('hsl.l')).hex().replace('#', '0x'), 16);
      }

      // Get gradient colors for backgrounds
      getGradientColors(palette, steps = 5) {
        if (!this.convertedPalettes[palette]) return this.convertedPalettes.neon;
        return chroma.scale(this.palettes[palette]).colors(steps).map(color =>
          parseInt(color.replace('#', '0x'), 16)
        );
      }

      // Helper method to convert hex to Phaser color
      hexToPhaser(hexColor) {
        return parseInt(hexColor.replace('#', '0x'), 16);
      }
    }

    // Initialize global color system
    const colorSystem = new ColorSystem();

    // BootScene: Enhanced with gradient loading and better visuals
    class BootScene extends Phaser.Scene {
      constructor() {
        super('BootScene');
      }

      preload() {
        const { width, height } = this.cameras.main;

        // Create gradient background for loading
        const gradientGraphics = this.add.graphics();
        gradientGraphics.fillGradientStyle(0x1e3c72, 0x1e3c72, 0x2a5298, 0x2a5298, 1);
        gradientGraphics.fillRect(0, 0, width, height);

        // Enhanced progress box with gradient
        let progressBox = this.add.graphics();
        progressBox.fillGradientStyle(0x333333, 0x333333, 0x555555, 0x555555, 0.9);
        progressBox.fillRoundedRect(width / 2 - 160, height / 2 - 25, 320, 50, 10);

        let loadingText = this.add.text(width / 2, height / 2 - 70, 'Loading Amazing Colors...', {
          font: '24px Arial',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 2
        }).setOrigin(0.5);

        // Add pulsing effect to loading text
        this.tweens.add({
          targets: loadingText,
          alpha: 0.3,
          duration: 1000,
          yoyo: true,
          repeat: -1
        });

        this.load.on('progress', (value) => {
          let bar = this.add.graphics();
          const gradientColors = colorSystem.getGradientColors('neon', 3);
          bar.fillGradientStyle(gradientColors[0], gradientColors[1], gradientColors[2], gradientColors[0], 1);
          bar.fillRoundedRect(width / 2 - 150, height / 2 - 15, 300 * value, 30, 8);
        });

        this.load.on('complete', () => {
          progressBox.destroy();
          loadingText.destroy();

          // Hide HTML loading screen
          const loadingDiv = document.getElementById('loading');
          if (loadingDiv) {
            loadingDiv.style.opacity = '0';
            setTimeout(() => loadingDiv.style.display = 'none', 500);
          }
        });

        // Enhanced cartoon-style particle textures
        let particleGraphics = this.make.graphics({ x: 0, y: 0, add: false });

        // Create a cartoon bubble-style particle
        particleGraphics.fillGradientStyle(0xFFFFFF, 0xFFFFFF, 0x4ECDC4, 0x45B7D1, 1);
        particleGraphics.fillCircle(4, 4, 3.5);

        // Add highlight for 3D effect
        particleGraphics.fillStyle(0xFFFFFF, 0.8);
        particleGraphics.fillCircle(5, 3, 1.5);

        // Add subtle outline
        particleGraphics.lineStyle(1, 0x000000, 0.3);
        particleGraphics.strokeCircle(4, 4, 3.5);
        particleGraphics.generateTexture('particle', 8, 8);

        // Create cartoon-style star texture
        let starGraphics = this.make.graphics({ x: 0, y: 0, add: false });

        // Draw cartoon star with gradient
        starGraphics.fillGradientStyle(0xFECA57, 0xFECA57, 0xE17055, 0xD63031, 1);

        const cx = 4, cy = 4, spikes = 5, outerRadius = 3.5, innerRadius = 1.8;
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy;
        const step = Math.PI / spikes;

        starGraphics.beginPath();
        starGraphics.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          starGraphics.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          starGraphics.lineTo(x, y);
          rot += step;
        }
        starGraphics.lineTo(cx, cy - outerRadius);
        starGraphics.closePath();
        starGraphics.fillPath();

        // Add star highlight
        starGraphics.fillStyle(0xFFFFAA, 0.9);
        starGraphics.fillCircle(5, 3, 1);

        // Add star outline
        starGraphics.lineStyle(1, 0x000000, 0.4);
        starGraphics.strokePath();
        starGraphics.generateTexture('star', 8, 8);

        // Create cartoon gem/diamond texture
        let diamondGraphics = this.make.graphics({ x: 0, y: 0, add: false });

        // Create a sparkling gem effect
        diamondGraphics.fillGradientStyle(0xA29BFE, 0xA29BFE, 0x6C5CE7, 0x5F3DC4, 1);

        // Diamond shape
        diamondGraphics.beginPath();
        diamondGraphics.moveTo(4, 1);
        diamondGraphics.lineTo(7, 4);
        diamondGraphics.lineTo(4, 7);
        diamondGraphics.lineTo(1, 4);
        diamondGraphics.closePath();
        diamondGraphics.fillPath();

        // Add sparkle highlights
        diamondGraphics.fillStyle(0xFFFFFF, 0.9);
        diamondGraphics.fillCircle(3, 3, 0.8);
        diamondGraphics.fillCircle(5.5, 2.5, 0.5);

        // Diamond outline
        diamondGraphics.lineStyle(1, 0x000000, 0.5);
        diamondGraphics.beginPath();
        diamondGraphics.moveTo(4, 1);
        diamondGraphics.lineTo(7, 4);
        diamondGraphics.lineTo(4, 7);
        diamondGraphics.lineTo(1, 4);
        diamondGraphics.closePath();
        diamondGraphics.strokePath();
        diamondGraphics.generateTexture('diamond', 8, 8);
      }

      create() {
        this.scene.start('MenuScene');
      }
    }

    // MenuScene: Enhanced with beautiful gradients and modern color palettes
    class MenuScene extends Phaser.Scene {
      constructor() {
        super('MenuScene');
      }

      create() {
        const { width, height } = this.cameras.main;

        // Create gradient background
        const bgGraphics = this.add.graphics();
        bgGraphics.fillGradientStyle(0x1a1a2e, 0x16213e, 0x0f3460, 0x533483, 1);
        bgGraphics.fillRect(0, 0, width, height);

        // Add animated background particles (Phaser 3.70 syntax)
        this.backgroundParticles = this.add.particles(0, 0, 'diamond', {
          x: { min: 0, max: width },
          y: { min: 0, max: height },
          lifespan: 8000,
          speed: { min: 20, max: 60 },
          scale: { start: 0.3, end: 0 },
          quantity: 2,
          blendMode: 'ADD',
          tint: colorSystem.convertedPalettes.cosmic,
          alpha: { start: 0.6, end: 0 }
        });

        // Enhanced title with glow effect
        const titleText = this.add.text(width / 2, 80, 'CHAIN BREAKER PRO', {
          font: '48px Arial',
          fill: '#ffffff',
          stroke: '#6c5ce7',
          strokeThickness: 4
        }).setOrigin(0.5);

        // Add glow effect to title
        this.tweens.add({
          targets: titleText,
          alpha: 0.7,
          duration: 2000,
          yoyo: true,
          repeat: -1
        });

        const subtitleText = this.add.text(width / 2, 150, 'Select Your Challenge', {
          font: '28px Arial',
          fill: '#fd79a8',
          stroke: '#000',
          strokeThickness: 2
        }).setOrigin(0.5);

        // Enhanced cartoon-themed mode designs
        this.modeDesigns = [
          {
            name: "Bubble Pop",
            theme: "Gentle bubbles and smooth precision",
            palette: 'neon',
            color: colorSystem.convertedPalettes.neon[0],
            bgColor: 0x2C3E50,
            particleColors: colorSystem.convertedPalettes.neon.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.neon,
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1,
            ringMovement: false
          },
          {
            name: "Cotton Candy",
            theme: "Sweet pastels with swift motions",
            palette: 'sunset',
            color: colorSystem.convertedPalettes.sunset[0],
            bgColor: 0x2D3436,
            particleColors: colorSystem.convertedPalettes.sunset.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.sunset,
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1.3,
            ringMovement: false
          },
          {
            name: "Ocean Waves",
            theme: "Flowing blues with dancing targets",
            palette: 'ocean',
            color: colorSystem.convertedPalettes.ocean[0],
            bgColor: 0x2C3E50,
            particleColors: colorSystem.convertedPalettes.ocean.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.ocean,
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1.2,
            ringMovement: true,
            ringSpeed: 0.0005
          },
          {
            name: "Golden Sunset",
            theme: "Warm golds with precise timing",
            palette: 'fire',
            color: colorSystem.convertedPalettes.fire[0],
            bgColor: 0x2D3436,
            particleColors: colorSystem.convertedPalettes.fire.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.fire,
            specialEffects: true,
            sweetSpotSize: 10,
            needleSpeed: 1.3,
            ringMovement: true,
            ringSpeed: 0.0007
          },
          {
            name: "Magic Prism",
            theme: "Enchanted colors with wild patterns",
            palette: 'cosmic',
            color: colorSystem.convertedPalettes.cosmic[0],
            bgColor: 0x2C3E50,
            particleColors: colorSystem.convertedPalettes.cosmic.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.cosmic,
            specialEffects: true,
            sweetSpotSize: 12,
            needleSpeed: 1.4,
            ringMovement: true,
            ringSpeed: 0.001,
            needleReverseProb: 0.005
          },
          {
            name: "Rainbow Master",
            theme: "The ultimate cartoon challenge",
            palette: 'aurora',
            color: colorSystem.convertedPalettes.aurora[0],
            bgColor: 0x34495E,
            particleColors: colorSystem.convertedPalettes.aurora.slice(0, 4),
            ringColors: colorSystem.convertedPalettes.aurora,
            specialEffects: true,
            sweetSpotSize: 8,
            needleSpeed: 1.8,
            ringMovement: true,
            ringSpeed: 0.0015,
            needleReverseProb: 0.005,
            pulsingRings: true
          }
        ];

        let startY = 220, spacing = 70;
        this.modeDesigns.forEach((mode, index) => {
          // Create background for each mode button
          const buttonBg = this.add.graphics();
          buttonBg.fillGradientStyle(mode.color, mode.color, mode.bgColor, mode.bgColor, 0.3);
          buttonBg.fillRoundedRect(width / 2 - 250, startY + index * spacing - 20, 500, 50, 15);
          buttonBg.lineStyle(2, mode.color, 0.8);
          buttonBg.strokeRoundedRect(width / 2 - 250, startY + index * spacing - 20, 500, 50, 15);

          // Mode name text with enhanced styling
          let modeText = this.add.text(width / 2 - 200, startY + index * spacing, mode.name, {
            font: '24px Arial',
            fill: '#ffffff',
            stroke: mode.color,
            strokeThickness: 2
          }).setOrigin(0, 0.5).setInteractive({ useHandCursor: true });

          // Theme description text
          let themeText = this.add.text(width / 2 - 200, startY + index * spacing + 15, mode.theme, {
            font: '14px Arial',
            fill: chroma(mode.color).brighten(1).hex(),
            alpha: 0.8
          }).setOrigin(0, 0.5);

          // Add interactive effects
          const buttonElements = [buttonBg, modeText, themeText];

          buttonElements.forEach(element => {
            if (element !== buttonBg) {
              element.setInteractive({ useHandCursor: true });
            }

            element.on('pointerdown', () => {
              // Add flash effect on selection
              this.tweens.add({
                targets: buttonBg,
                alpha: 1,
                duration: 100,
                yoyo: true,
                onComplete: () => {
                  this.scene.start('MainScene', { selectedMode: mode });
                }
              });
            });

            element.on('pointerover', () => {
              // Hover effects
              this.tweens.add({
                targets: [modeText, themeText],
                scale: 1.05,
                duration: 200
              });

              this.tweens.add({
                targets: buttonBg,
                alpha: 0.6,
                duration: 200
              });

              modeText.setFill(chroma(mode.color).brighten(2).hex());
            });

            element.on('pointerout', () => {
              // Reset hover effects
              this.tweens.add({
                targets: [modeText, themeText],
                scale: 1,
                duration: 200
              });

              this.tweens.add({
                targets: buttonBg,
                alpha: 0.3,
                duration: 200
              });

              modeText.setFill('#ffffff');
            });
          });

          // Add subtle pulsing animation to buttons
          this.tweens.add({
            targets: buttonBg,
            alpha: 0.2,
            duration: 3000 + (index * 500),
            yoyo: true,
            repeat: -1
          });
        });
      }
    }

    // MainScene: Oyun mekaniÄŸini barÄ±ndÄ±rÄ±r.
    class MainScene extends Phaser.Scene {
      constructor() {
        super('MainScene');
        // Object pools for memory efficiency
        this.scorePopupPool = [];
        this.ringPool = [];
        this.maxPoolSize = 20;
      }

      init(data) {
        this.selectedMode = data.selectedMode || null;
        this.level = 1;
        this.lastUpdateTime = 0;
        this.targetFPS = 60;
        this.frameBudget = 1000 / this.targetFPS;
      }

      create() {
        // Create dynamic gradient background based on selected mode
        const currentPalette = this.selectedMode ? this.selectedMode.palette : 'neon';
        const bgColors = colorSystem.getGradientColors(currentPalette, 4);

        this.backgroundGradient = this.add.graphics();
        this.backgroundGradient.fillGradientStyle(
          bgColors[0], bgColors[1], bgColors[2], bgColors[3], 1
        );
        this.backgroundGradient.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);

        // Enhanced background particles with dynamic colors (Phaser 3.70 syntax)
        this.backgroundParticles = this.add.particles(0, 0, 'star', {
          x: { min: 0, max: this.cameras.main.width },
          y: 0,
          lifespan: 8000,
          speedY: { min: 10, max: 30 },
          scale: { start: 1, end: 0 },
          quantity: 4,
          blendMode: 'ADD',
          tint: this.selectedMode ? this.selectedMode.particleColors : colorSystem.convertedPalettes.neon,
          alpha: { start: 0.7, end: 0 }
        });

        // Dynamic floating particles (Phaser 3.70 syntax)
        this.bgParticles = this.add.particles(0, 0, 'diamond', {
          x: { min: 0, max: this.cameras.main.width },
          y: { min: 0, max: this.cameras.main.height },
          lifespan: 12000,
          speed: { min: 15, max: 40 },
          angle: { min: 0, max: 360 },
          scale: { start: 0.4, end: 0 },
          quantity: 1,
          frequency: 800,
          blendMode: 'ADD',
          tint: this.selectedMode ? this.selectedMode.particleColors : colorSystem.convertedPalettes.neon,
          alpha: { start: 0.6, end: 0 }
        });

        // Enhanced spark emitter with palette colors (Phaser 3.70 syntax)
        this.sparkEmitter = this.add.particles(0, 0, 'particle', {
          lifespan: 400,
          speed: { min: -120, max: 120 },
          scale: { start: 1.0, end: 0 },
          quantity: 12,
          blendMode: 'ADD',
          tint: this.selectedMode ? this.selectedMode.ringColors : colorSystem.convertedPalettes.neon,
          emitting: false
        });

        // Sophisticated break particles (Phaser 3.70 syntax)
        this.breakParticles = this.add.particles(0, 0, 'diamond', {
          lifespan: 800,
          speed: { min: 80, max: 180 },
          scale: { start: 0.6, end: 0 },
          quantity: 18,
          blendMode: 'ADD',
          gravityY: 100,
          tint: this.selectedMode ? this.selectedMode.ringColors : colorSystem.convertedPalettes.fire,
          emitting: false
        });

        // Enhanced fever mode particles (Phaser 3.70 syntax)
        this.feverParticles = this.add.particles(0, 0, 'star', {
          x: { min: 0, max: this.cameras.main.width },
          y: { min: 0, max: this.cameras.main.height },
          lifespan: 4000,
          speed: { min: 60, max: 120 },
          scale: { start: 0.5, end: 0 },
          quantity: 6,
          blendMode: 'ADD',
          tint: colorSystem.convertedPalettes.fire,
          alpha: { start: 0.8, end: 0 },
          emitting: false
        });

        // Multi-colored confetti system (Phaser 3.70 syntax)
        this.confettiParticles = this.add.particles(0, 0, 'diamond', {
          x: { min: 0, max: this.cameras.main.width },
          y: -50,
          speed: { min: 150, max: 250 },
          angle: { min: 75, max: 105 },
          scale: { start: 0.8, end: 0 },
          lifespan: 3500,
          tint: [
            ...colorSystem.convertedPalettes.neon,
            ...colorSystem.convertedPalettes.sunset,
            ...colorSystem.convertedPalettes.cosmic
          ],
          emitting: false
        });

        this.center = { x: this.cameras.main.width / 2, y: this.cameras.main.height / 2 };

        // Remove the white flash effect as requested by user previously
        this.flash = this.add.rectangle(0, 0, this.cameras.main.width, this.cameras.main.height, 0x000000).setOrigin(0, 0);
        this.flash.alpha = 0;

        this.backgroundGlow = this.add.graphics();
        this.setupUI();
        this.setupParticleEffects();
        this.setupNeedle();
        this.input.on('pointerdown', this.handleInput, this);

        // Enhanced debug text with better styling
        this.debugText = this.add.text(10, 130, '', {
          font: '14px Arial',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 1,
          backgroundColor: 'rgba(0,0,0,0.3)',
          padding: { x: 8, y: 4 }
        });

        this.gameOverFlag = false;
        this.gameOverText = this.add.text(this.center.x, this.center.y, '', {
          font: '48px Arial',
          fill: this.selectedMode ? chroma(this.selectedMode.color).hex() : '#ff6b6b',
          align: 'center',
          stroke: '#000000',
          strokeThickness: 6
        }).setOrigin(0.5);

        // Ã‡ember ayarlarÄ±
        this.baseRadius = 100;
        this.ringThickness = 20;
        this.ringGap = 15;
        this.setupLevelDesigns();
        this.startLevel();
      }

      setupUI() {
        this.score = 0;
        this.combo = 0;
        this.lives = 3;
        this.regenDelay = 5000;

        // Get current mode colors for UI theming
        const modeColor = this.selectedMode ? chroma(this.selectedMode.color).hex() : '#00aaff';
        const accentColor = this.selectedMode ? chroma(this.selectedMode.color).brighten(1).hex() : '#66ffcc';

        // Enhanced text styles with dynamic colors
        const baseTextStyle = {
          font: '22px Arial',
          fill: '#ffffff',
          stroke: modeColor,
          strokeThickness: 2,
          backgroundColor: 'rgba(0,0,0,0.4)',
          padding: { x: 12, y: 6 }
        };

        // Level indicator with enhanced styling
        this.levelText = this.add.text(this.cameras.main.width / 2, 15, 'Level: ' + this.level, {
          ...baseTextStyle,
          font: '28px Arial',
          fill: accentColor
        }).setOrigin(0.5, 0);

        // Add pulsing effect to level text
        this.tweens.add({
          targets: this.levelText,
          alpha: 0.8,
          duration: 1500,
          yoyo: true,
          repeat: -1
        });

        // Score with gradient background
        const scoreBg = this.add.graphics();
        scoreBg.fillGradientStyle(0x000000, 0x333333, 0x000000, 0x333333, 0.7);
        scoreBg.fillRoundedRect(5, 5, 150, 35, 8);
        scoreBg.lineStyle(2, parseInt(modeColor.replace('#', '0x'), 16), 0.8);
        scoreBg.strokeRoundedRect(5, 5, 150, 35, 8);

        this.scoreText = this.add.text(15, 10, 'Score: 0', {
          ...baseTextStyle,
          backgroundColor: 'transparent'
        });

        // Combo counter with special effects
        const comboBg = this.add.graphics();
        comboBg.fillGradientStyle(0x000000, 0x444444, 0x000000, 0x444444, 0.7);
        comboBg.fillRoundedRect(5, 45, 150, 35, 8);

        this.comboText = this.add.text(15, 50, 'Combo: 0', {
          ...baseTextStyle,
          fill: '#ffff00',
          backgroundColor: 'transparent'
        });

        // Lives with heart-like styling
        const livesBg = this.add.graphics();
        livesBg.fillGradientStyle(0x330000, 0x660000, 0x330000, 0x660000, 0.7);
        livesBg.fillRoundedRect(5, 85, 120, 35, 8);

        this.livesText = this.add.text(15, 90, 'Lives: 3', {
          ...baseTextStyle,
          fill: '#ff6b6b',
          backgroundColor: 'transparent'
        });

        // Fever mode setup
        this.feverMode = false;
        this.feverModeDuration = 5000;
        this.feverTimer = 0;

        this.feverText = this.add.text(15, 130, '', {
          ...baseTextStyle,
          fill: '#ff00ff',
          font: '20px Arial'
        });

        // Theme description with better styling
        this.themeText = this.add.text(this.cameras.main.width / 2, 60,
          this.selectedMode ? this.selectedMode.theme : 'Standard Mode', {
          font: '18px Arial',
          fill: accentColor,
          stroke: '#000000',
          strokeThickness: 2,
          alpha: 0.9
        }).setOrigin(0.5, 0);

        // Add mode name indicator
        if (this.selectedMode) {
          this.modeNameText = this.add.text(this.cameras.main.width - 15, 15, this.selectedMode.name, {
            font: '20px Arial',
            fill: modeColor,
            stroke: '#000000',
            strokeThickness: 2,
            backgroundColor: 'rgba(0,0,0,0.5)',
            padding: { x: 10, y: 5 }
          }).setOrigin(1, 0);

          // Add subtle animation to mode name
          this.tweens.add({
            targets: this.modeNameText,
            alpha: 0.7,
            duration: 2000,
            yoyo: true,
            repeat: -1
          });
        }
      }

      setupParticleEffects() {
        // Bu bÃ¶lÃ¼mde daha Ã¶nce oluÅŸturduÄŸumuz partikÃ¼l emitter'leri zaten create() iÃ§erisinde ayarlandÄ±.
      }

      setupNeedle() {
        this.needle = this.add.graphics();
        this.needleAngle = 0;
        this.originalNeedleSpeed = Phaser.Math.DegToRad(180);
        this.needleSpeed = this.originalNeedleSpeed;
        this.needleReverseProb = 0;
      }

      setupLevelDesigns() {
        if (this.selectedMode) {
          this.baseMode = this.selectedMode;
        } else {
          this.levelDesigns = [{
            name: "Beginner's Circle",
            theme: "Standard rings with stationary targets",
            color: 0x00aaff,
            bgColor: 0x001a33,
            particleColors: [0x00aaff, 0x00cfff, 0x0099ff],
            ringColors: [0x00aaff, 0xff0000, 0x00ff00, 0xffff00],
            specialEffects: false,
            sweetSpotSize: 15,
            needleSpeed: 1,
            ringMovement: false
          }];
        }
      }

      getActiveDesign() {
        // Cache the active design to avoid recalculation
        if (this.cachedDesign && this.cachedDesign.level === this.level) {
          return this.cachedDesign;
        }

        let design;
        if (this.baseMode) {
          const mod = this.level - 1;
          const difficultyMultiplier = Math.min(mod * 0.08, 3); // Cap difficulty scaling

          design = {
            name: this.baseMode.name,
            theme: this.baseMode.theme,
            color: this.baseMode.color,
            bgColor: this.baseMode.bgColor,
            particleColors: this.baseMode.particleColors,
            ringColors: this.baseMode.ringColors,
            specialEffects: this.baseMode.specialEffects,
            sweetSpotSize: Math.max(this.baseMode.sweetSpotSize - mod * 0.5, 3), // Slower reduction
            needleSpeed: this.baseMode.needleSpeed * (1 + difficultyMultiplier),
            ringMovement: this.baseMode.ringMovement,
            ringSpeed: (this.baseMode.ringSpeed || 0) * (1 + difficultyMultiplier * 0.5),
            needleReverseProb: this.baseMode.needleReverseProb || 0
          };
        } else {
          const designIndex = Math.min(this.level - 1, this.levelDesigns.length - 1);
          design = this.levelDesigns[designIndex];
        }

        // Cache the design with level info
        this.cachedDesign = { ...design, level: this.level };
        return design;
      }

      update(time, delta) {
        if (this.gameOverFlag) return;

        // Frame budgeting for consistent performance
        const startTime = performance.now();
        let dt = delta / 1000;
        this.frameCount = (this.frameCount || 0) + 1;

        // Priority 1: Critical game logic (always runs)
        this.updateNeedle(dt);
        this.updateFeverMode(delta);

        // Priority 2: Visual updates (skip if frame budget exceeded)
        if (performance.now() - startTime < this.frameBudget * 0.7) {
          // Update background glow less frequently (every 3rd frame)
          if (this.frameCount % 3 === 0) {
            this.updateBackgroundGlow(time);
          }

          // Batch ring updates - limit to 2 rings per frame for performance
          const ringsToUpdate = Math.min(2, this.ringStack.length);
          for (let i = 0; i < ringsToUpdate; i++) {
            const ring = this.ringStack[i];
            if (ring.needsUpdate) {
              ring.update(delta);
            }
          }
        }

        // Priority 3: Non-critical updates (skip if running slow)
        if (performance.now() - startTime < this.frameBudget * 0.9) {
          if (this.frameCount % 15 === 0) { // Reduced frequency further
            this.debugText.setText(
              'FPS: ' + Math.round(1000 / delta) +
              '\nCombo: ' + this.combo +
              '\nLevel: ' + this.level
            );
          }
        }
      }

      updateBackgroundGlow(time) {
        const intensity = this.feverMode ? 0.3 : 0.1;
        const pulseFactor = Math.sin(time / 500) * 0.05 + intensity;
        this.backgroundGlow.clear();
        this.backgroundGlow.fillStyle(this.getActiveDesign().color, pulseFactor);
        this.backgroundGlow.fillCircle(this.center.x, this.center.y, this.baseRadius * 3);
      }

      updateNeedle(dt) {
        const design = this.getActiveDesign();
        if (design.needleReverseProb && Math.random() < design.needleReverseProb) {
          this.needleSpeed = -this.needleSpeed;
        }

        const oldAngle = this.needleAngle;
        this.needleAngle += this.needleSpeed * dt;
        if (this.needleAngle >= Math.PI * 2) this.needleAngle -= Math.PI * 2;
        if (this.needleAngle < 0) this.needleAngle += Math.PI * 2;

        // Only redraw if angle changed significantly (optimization)
        if (Math.abs(oldAngle - this.needleAngle) > 0.01) {
          this.drawNeedle();
        }
      }

      updateFeverMode(delta) {
        if (this.feverMode) {
          this.feverTimer -= delta;
          if (this.feverTimer <= 0) {
            this.feverMode = false;
            this.feverText.setText('');
          } else {
            this.feverText.setText('FEVER MODE: ' + Math.ceil(this.feverTimer / 1000) + 's');
          }
        }
      }

      drawNeedle() {
        if (!this.activeRing) return;

        this.needle.clear();

        // Enhanced cartoon-style needle colors
        const baseColor = this.feverMode ? chroma('#FF6B9D').hex() : chroma('#FFFFFF').hex();
        const shadowColor = this.feverMode ? chroma('#E84393').hex() : chroma('#DDD').hex();
        const highlightColor = this.feverMode ? chroma('#FD79A8').hex() : chroma('#FFFFAA').hex();

        const baseColorInt = parseInt(baseColor.replace('#', '0x'), 16);
        const shadowColorInt = parseInt(shadowColor.replace('#', '0x'), 16);
        const highlightColorInt = parseInt(highlightColor.replace('#', '0x'), 16);

        // Pre-calculate frequently used values
        const outerEdge = this.activeRing.radius + this.activeRing.thickness / 2;
        const margin = 46;
        const markerRadius = 18;

        // Cache trigonometric calculations
        const cosAngle = Math.cos(this.needleAngle);
        const sinAngle = Math.sin(this.needleAngle);

        // Pre-calculate positions
        const startDistance = outerEdge + margin;
        const endDistance = outerEdge + 5;

        const startX = this.center.x + cosAngle * startDistance;
        const startY = this.center.y + sinAngle * startDistance;
        const endX = this.center.x + cosAngle * endDistance;
        const endY = this.center.y + sinAngle * endDistance;

        // Draw needle shadow for depth
        this.needle.lineStyle(26, 0x000000, 0.3);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX + 3, startY + 3, endX + 3, endY + 3));

        // Draw needle outer glow
        this.needle.lineStyle(22, baseColorInt, 0.4);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX, startY, endX, endY));

        // Draw needle main body with gradient effect
        this.needle.lineStyle(12, shadowColorInt, 0.8);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX, startY, endX, endY));

        this.needle.lineStyle(6, baseColorInt, 1);
        this.needle.strokeLineShape(new Phaser.Geom.Line(startX, startY, endX, endY));

        // Draw cartoon-style marker ball with 3D effect
        // Shadow
        this.needle.fillStyle(0x000000, 0.4);
        this.needle.fillCircle(endX + 2, endY + 2, markerRadius);

        // Main marker body
        this.needle.fillStyle(shadowColorInt, 1);
        this.needle.fillCircle(endX, endY, markerRadius);

        // Highlight gradient
        this.needle.fillStyle(baseColorInt, 0.9);
        this.needle.fillCircle(endX, endY, markerRadius - 3);

        // Top highlight
        this.needle.fillStyle(highlightColorInt, 0.8);
        this.needle.fillCircle(endX - 4, endY - 4, markerRadius / 3);

        // Marker outline for definition
        this.needle.lineStyle(3, 0x000000, 0.7);
        this.needle.strokeCircle(endX, endY, markerRadius);

        // Inner highlight ring
        this.needle.lineStyle(2, highlightColorInt, 0.6);
        this.needle.strokeCircle(endX, endY, markerRadius - 6);
      }

      handleInput() {
        if (this.gameOverFlag || !this.activeRing) return;

        // Prevent input spam - minimum 100ms between inputs
        const now = performance.now();
        if (this.lastInputTime && now - this.lastInputTime < 100) return;
        this.lastInputTime = now;

        this.activeRing.inputReceived = true;

        // Cached angle difference calculation
        const angleDiff = Phaser.Math.Angle.Wrap(this.needleAngle - this.activeRing.sweetSpotAngle);
        const absAngleDiff = Math.abs(angleDiff);

        // Pre-calculate threshold to avoid repeated calculations
        if (!this.cachedThreshold) {
          this.cachedThreshold = Phaser.Math.DegToRad(this.getActiveDesign().sweetSpotSize);
        }

        if (absAngleDiff <= this.cachedThreshold) {
          this.handleSuccessfulHit();
        } else {
          this.handleMiss();
        }
        this.resetRegenTimer();
      }

      handleSuccessfulHit() {
        // Flash effect removed for better user experience

        // Trigger break particles at ring position
        this.breakParticles.explode(30, this.center.x, this.center.y);

        // Additional spark effects
        this.sparkEmitter.explode(30, this.center.x, this.center.y);
        this.cameras.main.shake(150, 0.01);

        // Background particles already configured with design colors

        // Activate fever mode particle effects
        if (this.feverMode) {
          this.feverParticles.start();
          this.time.delayedCall(500, () => { this.feverParticles.stop(); });
        }

        let multiplier = this.feverMode ? 2 : (1 + this.combo * 0.1);
        let points = Math.floor(10 * multiplier);
        let popupX = this.center.x + Math.cos(this.needleAngle) * this.activeRing.radius;
        let popupY = this.center.y + Math.sin(this.needleAngle) * this.activeRing.radius;
        this.showScorePopup(points, popupX, popupY);

        // Store reference to broken ring for animation
        const brokenRing = this.activeRing;

        // Immediately switch to next ring (don't wait for animation)
        Phaser.Utils.Array.Remove(this.ringStack, this.activeRing);
        if (this.ringStack.length === 0) {
          this.levelUp();
        } else {
          this.activeRing = this.ringStack[this.ringStack.length - 1];
        }

        // Play broken ring animation in background
        this.tweens.add({
          targets: brokenRing.graphics,
          scaleX: 0,
          scaleY: 0,
          alpha: 0,
          ease: 'Power2',
          duration: 800, // Slower animation for visual appeal
          onComplete: () => {
            brokenRing.destroy(); // Clean up when animation finishes
          }
        });
        this.combo++;
        this.comboText.setText('Combo: ' + this.combo);
        this.score += points;
        this.scoreText.setText('Score: ' + this.score);
        this.needleSpeed *= 1.03;
        this.regenDelay = Math.max(3000, this.regenDelay * 0.98);
        if (this.combo >= 5 && !this.feverMode) {
          this.activateFeverMode();
        }
      }

      // Optimized score popup with object pooling (Phaser 3.70 compatible)
      showScorePopup(points, x, y) {
        let popup = this.getPooledScorePopup();
        let baseScale = points >= 100 ? 2 : (points >= 50 ? 1.5 : 1);

        popup.setText('+' + points);
        popup.setPosition(x, y);
        popup.setScale(0);
        popup.setAlpha(1);
        popup.setVisible(true);

        // Chain tweens manually since timeline is not available in Phaser 3.70
        this.tweens.add({
          targets: popup,
          scaleX: baseScale * 1.2,
          scaleY: baseScale * 0.8,
          angle: -15,
          ease: 'Back.easeOut',
          duration: 400,
          onComplete: () => {
            // Second tween: normalize scale
            this.tweens.add({
              targets: popup,
              scaleX: baseScale,
              scaleY: baseScale,
              angle: 0,
              duration: 200,
              onComplete: () => {
                // Third tween: fade out and move up
                this.tweens.add({
                  targets: popup,
                  y: y - 80,
                  alpha: 0,
                  ease: 'Power2',
                  duration: 800,
                  delay: 100,
                  onComplete: () => this.returnPooledScorePopup(popup)
                });
              }
            });
          }
        });
      }

      getPooledScorePopup() {
        if (this.scorePopupPool.length > 0) {
          return this.scorePopupPool.pop();
        }
        return this.add.text(0, 0, '', {
          font: '48px Arial',
          fill: '#ffdd00',
          stroke: '#000000',
          strokeThickness: 4
        }).setOrigin(0.5).setShadow(4, 4, "#333333", 4, false, true);
      }

      returnPooledScorePopup(popup) {
        popup.setVisible(false);
        if (this.scorePopupPool.length < this.maxPoolSize) {
          this.scorePopupPool.push(popup);
        } else {
          popup.destroy();
        }
      }

      handleMiss() {
        this.combo = 0;
        this.comboText.setText('Combo: ' + this.combo);
        this.lives--;
        this.livesText.setText('Lives: ' + this.lives);
        this.cameras.main.shake(150, 0.015);
        this.tweens.add({
          targets: this.activeRing.graphics,
          x: this.activeRing.x + 5,
          y: this.activeRing.y + 5,
          yoyo: true,
          duration: 50,
          repeat: 2,
          onComplete: () => {
            this.activeRing.graphics.x = this.activeRing.x;
            this.activeRing.graphics.y = this.activeRing.y;
          }
        });
        if (this.lives <= 0) {
          this.gameOver();
        }
      }

      activateFeverMode() {
        this.feverMode = true;
        this.feverTimer = this.feverModeDuration;
        this.feverText.setText('FEVER MODE: 5s');
        this.cameras.main.flash(500, 255, 0, 255);
      }

      resetRegenTimer() {
        if (this.regenTimer) {
          this.regenTimer.remove(false);
        }
        this.regenTimer = this.time.addEvent({
          delay: this.regenDelay,
          callback: this.regenerateRing,
          callbackScope: this
        });
      }

      regenerateRing() {
        if (this.activeRing && !this.activeRing.inputReceived) {
          this.combo = 0;
          this.comboText.setText('Combo: 0');
        }
        if (this.ringStack.length >= 9) {
          this.gameOver();
          return;
        }
        let lastRadius = this.ringStack.length > 0
          ? this.ringStack[this.ringStack.length - 1].radius
          : this.baseRadius - (this.ringThickness + this.ringGap);
        let newRadius = lastRadius + this.ringThickness + this.ringGap;
        let ringColor = Phaser.Utils.Array.GetRandom(this.getActiveDesign().ringColors);
        let newRing = new Ring(this, this.center.x, this.center.y, newRadius, this.ringThickness, ringColor, this.getActiveDesign());
        this.ringStack.push(newRing);
        this.activeRing = newRing;
        this.resetRegenTimer();
      }

      levelUp() {
        this.confettiParticles.explode(50, this.center.x, this.center.y);
        this.cameras.main.flash(500, 0, 255, 0);
        let levelUpText = this.add.text(this.center.x, this.center.y, 'LEVEL UP!', {
          font: '48px Arial',
          fill: '#00ff00',
          stroke: '#000000',
          strokeThickness: 5
        }).setOrigin(0.5);
        this.tweens.add({
          targets: levelUpText,
          alpha: 0,
          scale: 2,
          duration: 1000,
          ease: 'Power2',
          onComplete: () => levelUpText.destroy()
        });
        this.level++;
        this.levelText.setText('Level: ' + this.level);
        const design = this.getActiveDesign();
        this.themeText.setText(design.name + ': ' + design.theme);
        this.needleSpeed = this.originalNeedleSpeed * design.needleSpeed;
        this.needleReverseProb = design.needleReverseProb || 0;
        this.regenDelay = Math.max(2000, 5000 - (this.level * 200));
        if (this.level % 3 === 0) {
          this.lives = Math.min(this.lives + 1, 5);
          this.livesText.setText('Lives: ' + this.lives);
          let bonusText = this.add.text(this.center.x, this.center.y + 60, '+1 LIFE!', {
            font: '32px Arial',
            fill: '#ff5555',
            stroke: '#000000',
            strokeThickness: 4
          }).setOrigin(0.5);
          this.tweens.add({
            targets: bonusText,
            alpha: 0,
            y: this.center.y + 30,
            duration: 1200,
            ease: 'Power2',
            onComplete: () => bonusText.destroy()
          });
        }
        this.time.delayedCall(1000, () => { this.startLevel(); }, [], this);
      }

      startLevel() {
        const design = this.getActiveDesign();
        this.currentRingColor = design.color;
        this.cameras.main.setBackgroundColor(design.bgColor);
        // Background particles already configured with design colors
        this.themeText.setText(design.name + ': ' + design.theme);
        this.ringStack = [];

        // Dynamic ring count based on difficulty
        const numRings = Math.min(8, 6 + Math.floor(this.level / 5));
        const radiusIncrement = this.ringThickness + this.ringGap;

        // Pre-calculate colors for better performance
        const colorPool = [...design.ringColors];

        for (let i = 0; i < numRings; i++) {
          const radius = this.baseRadius + i * radiusIncrement;
          const ringColor = colorPool[i % colorPool.length]; // Cycle through colors
          const ring = new Ring(this, this.center.x, this.center.y, radius, this.ringThickness, ringColor, design);
          this.ringStack.push(ring);
        }

        this.activeRing = this.ringStack[this.ringStack.length - 1];

        // Invalidate cached values when starting new level
        this.cachedDesign = null;
        this.cachedThreshold = null;

        this.resetRegenTimer();
      }

      gameOver() {
        this.gameOverFlag = true;
        this.gameOverText.setText('GAME OVER\nScore: ' + this.score + '\nLevel: ' + this.level + '\nClick to Restart');
        this.ringStack.forEach(ring => {
          this.tweens.add({
            targets: ring.graphics,
            alpha: 0,
            duration: 500
          });
        });
        this.input.once('pointerdown', () => {
          this.resetGame();
          this.gameOverFlag = false;
          this.gameOverText.setText('');
        });
      }

      resetGame() {
        // Clear all timers and tweens
        if (this.regenTimer) this.regenTimer.remove(false);
        this.tweens.killAll();

        // Clean up ring stack
        if (this.ringStack) {
          this.ringStack.forEach(ring => ring.destroy());
          this.ringStack.length = 0; // Clear array
        }

        // Clean up object pools
        if (this.scorePopupPool) {
          this.scorePopupPool.forEach(popup => popup.destroy());
          this.scorePopupPool.length = 0;
        }

        // Memory cleanup (texture cache removed for stability)

        // Reset game state
        this.level = 1;
        this.score = 0;
        this.combo = 0;
        this.lives = 3;
        this.needleSpeed = this.originalNeedleSpeed;
        this.regenDelay = 5000;
        this.feverMode = false;
        this.cachedThreshold = null; // Clear cached threshold
        this.frameCount = 0;

        // Update UI
        this.levelText.setText('Level: ' + this.level);
        this.scoreText.setText('Score: 0');
        this.comboText.setText('Combo: 0');
        this.livesText.setText('Lives: 3');
        this.feverText.setText('');

        this.startLevel();
      }
    }

    // Ring sÄ±nÄ±fÄ±: Her Ã§emberi, glow, 3D gÃ¶lge, sweet spot ve ok ile Ã§izer.
    class Ring {
      constructor(scene, x, y, radius, thickness, ringColor, design = {}) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.thickness = thickness;
        this.ringColor = ringColor || 0x00ffff;
        this.graphics = scene.add.graphics({ x: x, y: y });
        this.sweetSpotAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
        this.debugText = null;
        this.design = design;
        this.pulseDirection = 1;
        this.pulseMagnitude = 0;
        this.inputReceived = false;
        this.movementEnabled = design.ringMovement || false;
        this.movementSpeed = design.ringSpeed || 0.0005;
        this.needsUpdate = this.movementEnabled || design.pulsingRings;

        // Performance: Pre-calculate frequently used values
        this.arcWidth = Phaser.Math.DegToRad(this.design.sweetSpotSize || 15);
        this.arrowCosCache = Math.cos(this.sweetSpotAngle);
        this.arrowSinCache = Math.sin(this.sweetSpotAngle);
        this.isDirty = true;
        this.hasDrawn = false;

        if (this.scene.debugMode) {
          this.debugText = this.scene.add.text(this.x, this.y, '', { font: '12px Arial', fill: '#ff0000' }).setOrigin(0.5);
        }
        this.draw();
      }

      draw() {
        // Only clear if necessary - check if ring actually changed
        if (!this.isDirty && this.hasDrawn) return;

        this.graphics.clear();

        // Professional cartoon-style ring drawing with gradients and effects

        // Create a more vibrant ring color
        const brightColor = chroma(this.ringColor).brighten(0.3).hex();
        const darkColor = chroma(this.ringColor).darken(0.5).hex();
        const brightColorInt = parseInt(brightColor.replace('#', '0x'), 16);
        const darkColorInt = parseInt(darkColor.replace('#', '0x'), 16);

        // Draw shadow/depth effect
        this.graphics.fillStyle(0x000000, 0.4);
        this.graphics.fillCircle(4, 4, this.radius + 2);

        // Draw outer glow
        this.graphics.lineStyle(this.thickness + 8, this.ringColor, 0.15);
        this.graphics.strokeCircle(0, 0, this.radius);

        // Draw gradient ring with cartoon style
        this.graphics.lineStyle(this.thickness + 2, darkColorInt, 0.8);
        this.graphics.strokeCircle(0, 0, this.radius);

        // Inner bright highlight
        this.graphics.lineStyle(this.thickness - 4, brightColorInt, 0.9);
        this.graphics.strokeCircle(0, 0, this.radius);

        // Core ring color
        this.graphics.lineStyle(this.thickness - 8, this.ringColor, 1.0);
        this.graphics.strokeCircle(0, 0, this.radius);

        // Draw sweet spot with enhanced cartoon style
        const sweetSpotColor = chroma('#FFFFFF').hex();
        const sweetSpotColorInt = parseInt(sweetSpotColor.replace('#', '0x'), 16);

        // Sweet spot outer glow
        this.graphics.lineStyle(this.thickness + 4, sweetSpotColorInt, 0.3);
        this.graphics.beginPath();
        this.graphics.arc(0, 0, this.radius, this.sweetSpotAngle - this.arcWidth, this.sweetSpotAngle + this.arcWidth, false);
        this.graphics.strokePath();

        // Sweet spot main area
        this.graphics.lineStyle(this.thickness, sweetSpotColorInt, 0.9);
        this.graphics.beginPath();
        this.graphics.arc(0, 0, this.radius, this.sweetSpotAngle - this.arcWidth, this.sweetSpotAngle + this.arcWidth, false);
        this.graphics.strokePath();

        // Enhanced cartoon arrow with 3D effect
        const arrowX = this.arrowCosCache * (this.radius - this.thickness - 8);
        const arrowY = this.arrowSinCache * (this.radius - this.thickness - 8);

        // Arrow shadow
        this.graphics.fillStyle(0x000000, 0.4);
        this.graphics.beginPath();
        this.graphics.moveTo(arrowX + 2, arrowY + 2);
        this.graphics.lineTo(arrowX - 6, arrowY - 8);
        this.graphics.lineTo(arrowX + 10, arrowY - 8);
        this.graphics.closePath();
        this.graphics.fillPath();

        // Arrow main body with gradient effect
        this.graphics.fillStyle(sweetSpotColorInt, 1);
        this.graphics.beginPath();
        this.graphics.moveTo(arrowX, arrowY);
        this.graphics.lineTo(arrowX - 8, arrowY - 12);
        this.graphics.lineTo(arrowX + 8, arrowY - 12);
        this.graphics.closePath();
        this.graphics.fillPath();

        // Arrow highlight
        this.graphics.fillStyle(0xFFFFAA, 0.8);
        this.graphics.beginPath();
        this.graphics.moveTo(arrowX, arrowY);
        this.graphics.lineTo(arrowX - 4, arrowY - 8);
        this.graphics.lineTo(arrowX + 4, arrowY - 8);
        this.graphics.closePath();
        this.graphics.fillPath();

        // Arrow outline for definition
        this.graphics.lineStyle(2, 0x000000, 0.6);
        this.graphics.beginPath();
        this.graphics.moveTo(arrowX, arrowY);
        this.graphics.lineTo(arrowX - 8, arrowY - 12);
        this.graphics.lineTo(arrowX + 8, arrowY - 12);
        this.graphics.closePath();
        this.graphics.strokePath();

        this.hasDrawn = true;
        this.isDirty = false;

        if (this.debugText) {
          this.debugText.setText('Angle: ' + Math.round(Phaser.Math.RadToDeg(this.sweetSpotAngle)));
        }
      }

      update(delta) {
        let needsRedraw = false;

        if (this.movementEnabled) {
          const oldAngle = this.sweetSpotAngle;
          this.sweetSpotAngle += this.movementSpeed * delta;
          if (this.sweetSpotAngle > Math.PI * 2) this.sweetSpotAngle -= Math.PI * 2;

          // Only redraw if angle changed significantly
          if (Math.abs(oldAngle - this.sweetSpotAngle) > 0.005) {
            // Update cached trigonometric values
            this.arrowCosCache = Math.cos(this.sweetSpotAngle);
            this.arrowSinCache = Math.sin(this.sweetSpotAngle);
            this.isDirty = true;
            needsRedraw = true;
          }
        }

        if (this.design.pulsingRings) {
          const oldMagnitude = this.pulseMagnitude;
          this.pulseMagnitude += this.pulseDirection * 0.001 * delta;
          if (this.pulseMagnitude > 0.05 || this.pulseMagnitude < -0.05) this.pulseDirection *= -1;

          // Only update scale if magnitude changed significantly
          if (Math.abs(oldMagnitude - this.pulseMagnitude) > 0.001) {
            this.graphics.scaleX = 1 + this.pulseMagnitude;
            this.graphics.scaleY = 1 + this.pulseMagnitude;
          }
        }

        if (needsRedraw) {
          this.draw();
        }

        // Set needsUpdate flag for next frame
        this.needsUpdate = this.movementEnabled || this.design.pulsingRings;
      }

      destroy() {
        this.graphics.destroy();
        if (this.debugText) this.debugText.destroy();
      }
    }

    // Loading screen'i kaldÄ±r
    document.addEventListener('DOMContentLoaded', function () {
      const loadingElement = document.getElementById('loading');
      if (loadingElement) {
        loadingElement.style.display = 'none';
      }
    });

    const config = {
      type: Phaser.AUTO, // Let Phaser choose the best renderer
      width: window.innerWidth,
      height: window.innerHeight,
      parent: 'phaser-game',
      scene: [BootScene, MenuScene, MainScene],
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight
      },
      backgroundColor: '#000000',
      // Simplified config to avoid canvas creation issues
      dom: {
        createContainer: true
      }
    };

    // Simple, reliable game initialization
    window.addEventListener('load', function () {
      // Wait a moment for everything to be ready
      setTimeout(() => {
        const loadingElement = document.getElementById('loading');
        if (loadingElement) {
          loadingElement.style.display = 'none';
        }

        // Create the game
        const game = new Phaser.Game(config);

        // Handle window resize for fullscreen support
        window.addEventListener('resize', () => {
          game.scale.resize(window.innerWidth, window.innerHeight);
        });
      }, 500);
    });
  </script>
</body>

</html>